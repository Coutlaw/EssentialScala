/*=============================================================================   Chapter 4: Traits */// This example does not use traits so anonymous and user both are created independentlyimport java.util.Datecase class Anonymous(id: String, createdAt: Date = new Date())case class User(                 id: String,                 email: String,                 createdAt: Date = new Date()               )// This example is created using traitstrait Visitor {  def id: String      // Unique id assigned to each user  def createdAt: Date // Date this user first visited the site  // How long has this visitor been around?  def age: Long = new Date().getTime - createdAt.getTime}case class Anonymous2(                      id: String,                      createdAt: Date = new Date()                    ) extends Visitorcase class User2(                 id: String,                 email: String,                 createdAt: Date = new Date()               ) extends Visitordef older(v1: Visitor, v2: Visitor): Boolean =  v1.createdAt.before(v2.createdAt)older(Anonymous2("1"), User2("2", "test@example.com"))val anon = Anonymous2("annon1")anon.createdAtanon.age/*=============================================================================   4.1 examples *//** Demand for Cat Simulator 1.0 is exploding! For v2 we’re going to go beyond the domestic cat to model Tigers, Lions, and Panthers in addition to the Cat. Define a trait Feline and then define all the different species as subtypes of Feline. To make things interesting, define:* on Feline a colour as before;* on Feline a String sound, which for a cat is "meow" and is "roar" for all other felines;* only Cat has a favourite food; and* Lions have an Int maneSize.*/trait Feline{  def colour: String  def sound: String}// the cat extends feline, can be given the fields color and favFood, and sets sound to meowcase class Cat(colour: String, favFood: String) extends Feline{  val sound = "meow"}case class Tiger(colour: String) extends Feline{  val sound = "roar"}case class Lion(colour: String, maneSize: Int) extends Feline{  val sound = "roar"}case class Panther(colour: String) extends Feline{  val sound = "roar"}/*Define a trait called Shape and give it three abstract methods:sides returns the number of sides;perimeter returns the total length of the sides;area returns the area.Implement Shape with three classes: Circle, Rectangle, and Square.In each case provide implementations of each of the three methods.Ensure that the main constructor parameters of each shape(e.g. the radius of the circle) are accessible as fields. */// evolves into a sealed trait examplesealed trait Shape {  def sides: Int  def perimeter: Double  def area: Double}case class Square( length: Double ) extends Shape{  val sides = 4  val perimeter = length*4  val area = length*length}case class Rectangle( length: Double, width: Double )  extends Shape{  val sides = 4  val perimeter = (2*length) + (2*width)  val area = length * width}case class Circle( radius: Double ) extends Shape{  val sides =1  val perimeter = 2 * math.Pi * radius  val area = math.Pi*radius*radius}// singleton object draw, that describes the shapes when calledobject Draw{  def apply(shape: Shape): String = shape match{    case Rectangle(width, height) =>      s"A rectangle of width $width cm and height $height cm"    case Square(size) =>      s"A square of size $size cm"    case Circle(radius) =>      s"A circle of radius $radius cm"  }}// use the Draw singleton objectDraw(Circle(10))/*4.2.2.2 The Color and the ShapeWrite a sealed trait Color to make our shapes more interesting.give Color three properties for its RGB values;create three predefined colours: Red, Yellow, and Pink;provide a means for people to produce their own custom Colors with their own RGB values;provide a means for people to tell whether any Color is “light” or “dark”.A lot of this exercise is left deliberately open to interpretation. The important thing is to practice working with traits, classes, and objects.Decisions such as how to model colours and what is considered a light or dark colour can either be left up to you or discussed with other class members.Edit the code for Shape and its subtypes to add a colour to each shape.Finally, update the code for Draw.apply to print the colour of the argument as well as its shape and dimensions:*/// Shape uses Color so we define Color first:sealed trait Color {  // We decided to store RGB values as doubles between 0.0 and 1.0.  //  // It is always good practice to define abstract members as `defs`  // so we can implement them with `defs`, `vals` or `vars`.  def red: Double  def green: Double  def blue: Double  // We decided to define a "light" colour as one with  // an average RGB of more than 0.5:  def isLight = (red + green + blue) / 3.0 > 0.5  def isDark = !isLight}case object Red extends Color {  // Here we have implemented the RGB values as `vals`  // because the values cannot change:  val red = 1.0  val green = 0.0  val blue = 0.0}case object Yellow extends Color {  // Here we have implemented the RGB values as `vals`  // because the values cannot change:  val red = 1.0  val green = 1.0  val blue = 0.0}case object Pink extends Color {  // Here we have implemented the RGB values as `vals`  // because the values cannot change:  val red = 1.0  val green = 0.0  val blue = 1.0}// The arguments to the case class here generate `val` declarations// that implement the RGB methods from `Color`:final case class CustomColor(                              red: Double,                              green: Double,                              blue: Double) extends Color// The code from the previous exercise comes across almost verbatim,// except that we add a `color` field to `Shape` and its subtypes:sealed trait Shape2 {  def sides: Int  def perimeter: Double  def area: Double  def color: Color}final case class Circle2(radius: Double, color: Color) extends Shape2 {  val sides = 1  val perimeter = 2 * math.Pi * radius  val area = math.Pi * radius * radius}sealed trait Rectangular extends Shape2 {  def width: Double  def height: Double  val sides = 4  val perimeter = 2 * width + 2 * height  val area = width * height}final case class Square2(size: Double, color: Color) extends Rectangular {  val width = size  val height = size}final case class Rectangle2(                            width: Double,                            height: Double,                            color: Color                          ) extends Rectangular// We decided to overload the `Draw.apply` method for `Shape` and// `Color` on the basis that we may want to reuse the `Color` code// directly elsewhere:object Draw2 {  def apply(shape: Shape2): String = shape match {    case Circle2(radius, color) =>      s"A ${Draw2(color)} circle of radius ${radius}cm"    case Square2(size, color) =>      s"A ${Draw2(color)} square of size ${size}cm"    case Rectangle2(width, height, color) =>      s"A ${Draw2(color)} rectangle of width ${width}cm and height ${height}cm"  }  def apply(color: Color): String = color match {    // We deal with each of the predefined Colors with special cases:    case Red    => "red"    case Yellow => "yellow"    case Pink   => "pink"    case color  => if(color.isLight) "light" else "dark"  }}// Test code:Draw2(Circle2(10, Pink))// res29: String = A pink circle of radius 10.0cmDraw2(Rectangle2(3, 4, CustomColor(0.4, 0.4, 0.6)))// res30: String = A dark rectangle of width 3.0cm and height 4.0cm// Dealing with scala patterns// If a traffic light is red, green, or yellow, translate to scala code// is-a orsealed trait TrafficLightcase object red extends TrafficLightcase object green extends TrafficLightcase object yellow extends TrafficLight// a calculations may succeed with an Int result or fail with a string message, implement this// has-a orsealed trait Calculationfinal case class Success(result: Int) extends Calculationfinal case class Failure(reason: String) extends Calculation//Bottled water has a size int, a source( well, spring or tap), and a boolean carbonatedsealed trait Sourcecase object Well extends Sourcecase object Spring extends Sourcecase object Tap extends Sourcefinal case class BottledWater(size: Int, source: Source, carbonated: Boolean)// structural recursion// we can use the override function to override classes